name: "Helm deploy Action"
description: "GitHub Action to install/upgrade services using Helm"
inputs:
  deploy_mode:
    description: |
      Deployment mode:
      - 'install' for clean installation
      - 'update' to upgrade an existing release
    required: true
    default: 'install'

  restricted:
    description: |
      - 'true': helm installation by user with restricted rights
      - 'false': helm installation by cluster admin user
    required: true
    default: 'false'
    type: boolean

  path_to_template:
    description: |
      Path to template file in qubership-test-pipelines repository
      Example: 'templates/consul-service/consul_clean_infra_passport.yml'
    required: true

  service_branch:
    description: |
      Branch in service repository
    required: true

  service_name:
    description: |
      Helm release name
    required: true

  repository_name:
    description: |
      Service repository name (without organization prefix)
      Example: 'qubership-consul' for https://github.com/Netcracker/qubership-consul
    required: true

  path_to_chart:
    description: |
      Path to helm chart within service repository
      Example: 'charts/helm/consul-service'
    required: true

  namespace:
    description: |
      Kubernetes namespace for service installation
    required: true

  helm_charts_release_config:
    description: |
      Path to helm-charts-release-config.yaml in pipeline repository
    required: false

  resource_folder:
    description: |
      Folder with resources for creating before installation
    required: true

  docker_tag:
    description: "Full docker image"
    required: false

runs:
  using: 'composite'
  steps:
    - name: Checkout repo
      uses: actions/checkout@v4
      with:
        ref: '${{inputs.service_branch}}'
        repository: 'Netcracker/${{inputs.repository_name}}'
        path: '${{inputs.repository_name}}'

    - name: Create namespace
      if: inputs.deploy_mode == 'install'
      shell: bash
      # language=bash
      run: |
        if ! kubectl get namespace ${{inputs.namespace}} >/dev/null 2>&1; then
        kubectl create namespace ${{inputs.namespace}}
        else
        echo "Namespace '${{inputs.namespace}}' already exists"
        fi

    - name: Create resources
      if: inputs.resource_folder != ''
      shell: bash
      # language=bash
      run: |
        folder="${{inputs.resource_folder}}"
        files=($(find "$folder" -type f))
        echo $files
        for file in "${files[@]}"; do
          echo "Applying $file"
          kubectl create -f "$file"
        done

    - name: Name template
      shell: bash
      # language=bash
      run: |
        echo ${{inputs.path_to_template}}
        cp ${{inputs.path_to_template}} ${{inputs.repository_name}}/${{inputs.path_to_chart}}
        ls -la
    #    ls -la
    #    cp ${{inputs.path_to_template}} ${{inputs.repository_name}}/${{inputs.path_to_chart}}

    - name: Replace slash in service branch
      id: replace_slash
      shell: bash
      # language=bash
      run: |
        service_branch="${{inputs.service_branch}}"
        if [[ "${service_branch}" == *"/"* ]]; then
          service_branch_updated=$(echo "${service_branch}" | tr '/' '_')
        else
          service_branch_updated=${service_branch}
        fi
        echo ${service_branch_updated}
        echo "service_branch_updated=${service_branch_updated}" >> $GITHUB_OUTPUT
        echo "docker_tag"
        echo ${{ inputs.docker_tag }}

    - name: Initialize error flag
      shell: bash
      # language=bash
      run: echo "ERROR_FLAG=false" >> $GITHUB_ENV

    - name: Install Postgres
      shell: bash
      run: |
        helm repo add bitnami https://charts.bitnami.com/bitnami
        
        helm install my-postgres bitnami/postgresql -n ${{inputs.namespace}} \
          --set image.registry=docker.io \
          --set image.repository=bitnamilegacy/postgresql \
          --set image.tag=14.2.0 \
          --set auth.username=postgres \
          --set auth.password=postgrestest \
          --set auth.database=postgres

        pod=$(kubectl get pods -n ${{inputs.namespace}} -o name | head -n 1 | cut -d/ -f2)
        kubectl wait pod "$pod" -n ${{inputs.namespace}} \
          --for=condition=Ready \
          --timeout=120s || {
          echo "‚ùå Pod $pod did not become ready in time"
          ERROR_FLAG=true
          exit 1
        }

    - name: Install MongoDB
      shell: bash
      run: |
        helm repo add percona https://percona.github.io/percona-helm-charts/
        helm repo update
        
        helm install percona-operator percona/psmdb-operator --namespace mongo --create-namespace
        pod=$(kubectl get pods -n mongo -o name | grep -vE 'postgres' | head -n 1 | cut -d/ -f2)
        kubectl wait pod "$pod" -n mongo \
          --for=condition=Ready \
          --timeout=120s || {
          echo "‚ùå Pod $pod did not become ready in time"
          exit 1
        }
        
        
        helm install my-mongo percona/psmdb-db \
          --namespace mongo \
          --set psmdb.security.enabled=true \
          --set psmdb.db.enabled=true \
          --set psmdb.db.name=my-database \
          --set customResource.secrets.users[0].name=customadmin \
          --set customResource.secrets.users[0].user=custom \
          --set customResource.secrets.users[0].password=custompass \
          --set customResource.secrets.users[0].roles[0].db=admin \
          --set customResource.secrets.users[0].roles[0].role=clusterAdmin
  
  
        sleep 5
        
        pod=$(kubectl get pods -n mongo -o name | grep -vE 'percona' | head -n 1 | cut -d/ -f2)
        kubectl wait pod "$pod" -n mongo \
          --for=condition=Ready \
          --timeout=600s || {
          echo "‚ùå Pod $pod did not become ready in time"
          exit 1
        }
        
        sleep 60

    - name: Install/update service with helm
      shell: bash
      run: |
        # ‚ñ∂Ô∏è ${{inputs.deploy_mode}} ${{inputs.service_name}} with Helm
        template_name=$(basename "${{inputs.path_to_template}}")
        echo $template_name
        cd ${{inputs.repository_name}}/${{inputs.path_to_chart}}
        
        if [ -n "${{ inputs.docker_tag }}" ]; then
          echo "Using docker_tag: ${{ inputs.docker_tag }}"
          helm ${{inputs.deploy_mode}} ${{inputs.service_name}} . -f $template_name -n ${{inputs.namespace}} --set-string DOCKER_TAG=${{ inputs.docker_tag }} --debug --wait --timeout 7m
        else
         echo "No docker_tag provided. Using value from values-dev.yaml"
         helm ${{inputs.deploy_mode}} ${{inputs.service_name}} . -f $template_name -n ${{inputs.namespace}} --debug --wait --timeout 7m
        fi 
        
        sleep 120

    - name: Debug
      shell: bash
      if: always()
      run: |
        echo "Get pods $pod"
        kubectl get pods -n ${{inputs.namespace}}
        
        sleep 120
        
        echo "Describe pod"
        kubectl describe pod $(kubectl get pods -n ${{inputs.namespace}} --no-headers | awk 'NR==1 {print $1}') -n ${{inputs.namespace}}
        echo "Get secret service"
        kubectl get secrets -n ${{inputs.namespace}}
        kubectl get secret -n ${{inputs.namespace}} atp-itf-lite-backend-secrets  -o yaml
        kubectl get secret -n ${{inputs.namespace}} atp-itf-lite-backend-secrets  -o json | \
          jq -r '.data | to_entries[] | "\(.key): \(.value | @base64d)"'        
        echo "End describe"
        
        echo "Describe mongo pod"
        kubectl get ns
        helm list --all-namespaces | grep mongo
        kubectl get svc -n mongo
        echo "Check endpoints"
        kubectl get endpoints -n mongo my-mongo-psmdb-db-mongos
        kubectl get pods -n mongo -l app.kubernetes.io/component=mongos
        kubectl get secrets -n mongo
        kubectl get pods -n mongo
        echo "Get secret"
        kubectl get secret -n mongo my-mongo-psmdb-db-secrets -o jsonpath="{.data.MONGODB_USER_ADMIN_PASSWORD}" | base64 -d
        kubectl get secret -n mongo my-mongo-psmdb-db-secrets -o jsonpath="{.data.MONGODB_USER_ADMIN_USER}" | base64 -d
        kubectl get secret -n mongo my-mongo-psmdb-db-secrets -o yaml
        kubectl get secret -n mongo my-mongo-psmdb-db-secrets -o json | \
          jq -r '.data | to_entries[] | "\(.key): \(.value | @base64d)"'
    
        echo "End describe mongo pod"
        
        for pod in $(kubectl get pods -n ${{inputs.namespace}} --no-headers -o custom-columns=":metadata.name"); do 
          echo "üì¶ Logs from pod: $pod"
        
          if ! kubectl logs "$pod" -n ${{inputs.namespace}}; then
            echo "‚ö†Ô∏è Could not fetch current logs for $pod"
          fi
        
          restart_count=$(kubectl get pod "$pod" -n ${{inputs.namespace}} -o jsonpath="{.status.containerStatuses[0].restartCount}")
        
          if [[ "$restart_count" -gt 0 ]]; then
            echo "üîÅ Previous logs (before restart) for pod: $pod"
            if ! kubectl logs "$pod" -n ${{inputs.namespace}} --previous; then
              echo "‚ö†Ô∏è Could not fetch previous logs for $pod"
            fi
          fi
        
        done
        
        echo " Get pods $pod"
        kubectl get pods -n ${{inputs.namespace}}

    - name: Get docker images
      shell: bash
      # language=bash
      run: |
        # ‚ñ∂Ô∏è Get docker images
        kubectl get pods -n ${{inputs.namespace}} -o go-template --template="{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}"